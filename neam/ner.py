#!/usr/bin/python3
"""
ner.py

Uses the Stanford Parser to tag named entities from a provided text file, then converts Stanford's
output to a tagged string.

:author: Graham Still
"""
import sys
import re
import json
import os
from enum import Enum
import subprocess

""" Correspondences between Stanford tags and TEI tags """
TAG_DICT = {
    'PERSON': 'persName',
    'LOCATION': 'placeName',
    'ORGANIZATION': 'orgName'
}


def main():
    file_name = sys.argv[1]
    output = subprocess.run(['java/run', file_name], stdout=subprocess.PIPE)
    print(output)

    #converter = TEIConverter(TAG_DICT)

    #with open(file_name) as journal:
        #for line in journal:
            # Let's say for now that page numbers are being excluded. In Journal 2, for example,
            # page 1 is excluded, but other pages are embedded in the text - pretty ugly.
            #if PAGE_PATTERN.match(line):
            #    continue

            #tokens = word_tokenize(line)
            #tagged = tagger.tag(tokens)
            #converter.feed(tagged)

    #print(converter.to_s())


def load_config():
    config_path = os.path.join(os.path.dirname(__file__), '../config.json')

    try:
        with open(config_path) as config_file:
            config = json.load(config_file)
    except FileNotFoundError:
        print('Could not load config - have you set config.json?')
        sys.exit(1)
    except json.decoder.JSONDecodeError:
        print('config.json is not valid JSON!')
        sys.exit(1)

    return config


class Month(Enum):
    Jan = 0
    Feb = 1
    Mar = 2
    Apr = 3
    May = 4
    Jun = 5
    Jul = 6
    Aug = 7
    Sept = 8
    Oct = 9
    Nov = 10
    Dec = 11


class TEIConverter:
    """
    Maintains an internal state of XML that has been converted from NE-tagged text
    """

    """ The symbol used by the parser to indicate that a term is not a named entity """
    _NO_NE = 'O'

    @property
    def NO_NE(self):
        return TEIConverter._NO_NE
    
    def __init__(self, tags = None):
        """
        Initializes the converter

        :param tags: An optional dict mapping parser tags to output tags
        :type tags: dict of str
        """
        self.builder = []
        self.last_tag = self.NO_NE
        self.tags = tags or {}
        self.year = '1892'

    def feed(self, tagged):
        """
        Feeds some tagged text into the converter

        :param tagged: Named-entity tagged words
        :type tagged: list of tuple
        """
        for pair in tagged:
            token, current_tag = pair

            if current_tag != self.last_tag:
                # If there is a transition from a tag to something else, add a closing tag
                if self.last_tag != self.NO_NE:
                    self.builder.append(self.close_tag())

                # If there is a transition into a tag, add an opening tag
                if current_tag != self.NO_NE:
                    self.builder.append(self.open_tag(current_tag))

            self.builder.append(token)
            self.last_tag = current_tag

        self.builder.append('\n')

    def open_tag(self, tag):
        """
        Adds an opening tag to the builder

        :param tag: The name of the tag to open (without angle brackets)
        :type tag: str
        :return: The opened tag
        :rtype: str
        """
        if tag in self.tags:
            tag = self.tags[tag]
        return '<{}>'.format(tag)

    def close_tag(self, tag = None):
        """
        Adds a closing tag to the builder

        :param tag: The name of the tag to close (without angle brackets); if unspecified, the
                    current last_tag will be used
        :type tag: str
        :return: The closed tag
        :rtype: str
        """
        tag = tag or self.last_tag

        if tag in self.tags:
            tag = self.tags[tag]

        return '</{}>'.format(tag)

    def to_s(self):
        """
        Gets the current text generated by the converter

        :rtype: str
        """
        output = ' '.join(self.builder)

        # Close the last tag if there is one
        if not self.last_tag == self.NO_NE:
            output += ' ' + self.close_tag()

        output = self.clean_up(output)

        return self.annotate(output)

    def clean_up(self, text):
        """
        Adjusts a string of marked up text to make it look more natural

        :type text: str
        :rtype: str
        """
        # Get rid of spaces before closing tags
        text = re.sub('\s+(?=</)', '', text)
        # Get rid of spaces after newlines
        text = re.sub('(?<=\n) ', '', text)
        # Get rid of spaces before newlines
        text = re.sub(' (?=\n)', '', text)
        # Get rid of spaces after opening tags
        text = re.sub('(<[^/>]+>)\s+', '\g<1>', text)
        # Get rid of spaces before terminating punctuation
        text = re.sub('(\S)\s+([,.:;!?])', '\g<1>\g<2>', text)
        # Get rid of empty lines in the middle of paragraphs
        text = re.sub('(?<=[^.>])\n\n', '', text)
        text = re.sub('(?<=\.)\n\n', '\n', text)

        return text

    def annotate(self, text):
        """
        Adds title and paragraph tags to a string of marked up text

        :type text: str
        :rtype: str
        """
        # Brute force regex to find title-looking things
        text = re.sub('(?:^|\n)(?:.*(?:- |\. |, ))?(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sept|Oct|Nov|Dec)(?:\.?|[a-z]+) +(\d+)(?:st|nd|rd|th)?(?: +(\d{4}))?(?:\..*)?\n', self.format_title, text)
        #text = re.sub('(?:^|\n)(?:((?:\S+ ){1,3}\S+\.) *\n? *)?((Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sept|Oct|Nov|Dec)(?:\.?|[a-z]+) +(\d+)(?:st|nd|rd|th)?\.?(?: +(\d{4}))?\.?.*)\n', self.format_title, text)
        # Add closing tags where applicable
        text = re.sub('(?<=.|\n)(?=<div)', '</p></div>', text)

        # Close the final entry and wrap everything in a body tag
        return '<body>{}</p></div></body>'.format(text)

    def format_title(self, matchobj):
        title = matchobj.group(0).strip()
        month = Month[matchobj.group(1)].value + 1
        day = matchobj.group(2)
        year = matchobj.group(3)

        if year:
            self.year = year
        month = pad_int(month, 2)
        day = pad_int(day, 2)

        return '<div xml:id="EBA{}{}{}" type="Entry"><p><title>{}</title></p><p>'.format(self.year, month, day, title)

    
def pad_int(x, size):
    number = str(x)
    pad = '0' * (size - len(number))

    return pad + number


main()
