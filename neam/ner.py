#!/usr/bin/python3
"""
ner.py

Uses the Stanford Parser to tag named entities from a provided text file, then converts Stanford's
output to a tagged string.

:author: Graham Still
"""
import sys
import re
from enum import Enum
from nltk.tag import StanfordNERTagger
from nltk.tokenize import word_tokenize

""" The location of the trained model file """
CLASSIFICATION_MODEL = '/home2/vwr/tmp/ling575g/stanford_models/edu/stanford/nlp/models/ner/english.all.3class.distsim.crf.ser.gz'

""" The location of the .jar file for the NER tagger """
TAGGER_JAR = '/NLP_TOOLS/tool_sets/stanford-corenlp/latest/stanford-corenlp-3.7.0.jar'

PAGE_PATTERN = re.compile('^Page \d+')

""" Correspondences between Stanford tags and TEI tags """
TAG_DICT = {
    'PERSON': 'persName',
    'LOCATION': 'placeName'
}


def main():
    file_name = sys.argv[1]
    tagger = StanfordNERTagger(CLASSIFICATION_MODEL, TAGGER_JAR)
    converter = TEIConverter(TAG_DICT)

    with open(file_name) as journal:
        for line in journal:
            # Let's say for now that page numbers are being excluded. In Journal 2, for example,
            # page 1 is excluded, but other pages are embedded in the text - pretty ugly.
            if PAGE_PATTERN.match(line):
                continue

            tokens = word_tokenize(line)
            tagged = tagger.tag(tokens)
            converter.feed(tagged)

    print(converter.to_s())


class Month(Enum):
    Jan = 0
    Feb = 1
    Mar = 2
    Apr = 3
    May = 4
    Jun = 5
    Jul = 6
    Aug = 7
    Sept = 8
    Oct = 9
    Nov = 10
    Dec = 11


class TEIConverter:
    """
    Maintains an internal state of XML that has been converted from NE-tagged text
    """

    """ The symbol used by the parser to indicate that a term is not a named entity """
    _NO_NE = 'O'

    @property
    def NO_NE(self):
        return TEIConverter._NO_NE
    
    def __init__(self, tags = None):
        """
        Initializes the converter

        :param tags: An optional dict mapping parser tags to output tags
        :type tags: dict of str
        """
        self.builder = []
        self.last_tag = self.NO_NE
        self.tags = tags or {}
        self.year = '1892'

    def feed(self, tagged):
        """
        Feeds some tagged text into the converter

        :param tagged: Named-entity tagged words
        :type tagged: list of tuple
        """
        for pair in tagged:
            token, current_tag = pair

            if current_tag != self.last_tag:
                # If there is a transition from a tag to something else, add a closing tag
                if self.last_tag != self.NO_NE:
                    self.builder.append(self.close_tag())

                # If there is a transition into a tag, add an opening tag
                if current_tag != self.NO_NE:
                    self.builder.append(self.open_tag(current_tag))

            self.builder.append(token)
            self.last_tag = current_tag

        self.builder.append('\n')

    def open_tag(self, tag):
        """
        Adds an opening tag to the builder

        :param tag: The name of the tag to open (without angle brackets)
        :type tag: str
        :return: The opened tag
        :rtype: str
        """
        if tag in self.tags:
            tag = self.tags[tag]
        return '<{}>'.format(tag)

    def close_tag(self, tag = None):
        """
        Adds a closing tag to the builder

        :param tag: The name of the tag to close (without angle brackets); if unspecified, the
                    current last_tag will be used
        :type tag: str
        :return: The closed tag
        :rtype: str
        """
        tag = tag or self.last_tag

        if tag in self.tags:
            tag = self.tags[tag]

        return '</{}>'.format(tag)

    def to_s(self):
        """
        Gets the current text generated by the converter

        :rtype: str
        """
        output = ' '.join(self.builder)

        # Close the last tag if there is one
        if not self.last_tag == self.NO_NE:
            output += ' ' + self.close_tag()

        output = self.clean_up(output)

        return self.annotate(output)

    def clean_up(self, text):
        """
        Adjusts a string of marked up text to make it look more natural

        :type text: str
        :rtype: str
        """
        # Get rid of spaces before closing tags
        text = re.sub('\s+(?=</)', '', text)
        # Get rid of spaces after newlines
        text = re.sub('(?<=\n) ', '', text)
        # Get rid of spaces before newlines
        text = re.sub(' (?=\n)', '', text)
        # Get rid of spaces after opening tags
        text = re.sub('(<[^/>]+>)\s+', '\g<1>', text)
        # Get rid of spaces before terminating punctuation
        text = re.sub('(\S)\s+([,.:;!?])', '\g<1>\g<2>', text)
        # Get rid of empty lines in the middle of paragraphs
        text = re.sub('(?<=[^.>])\n\n', '', text)
        text = re.sub('(?<=\.)\n\n', '\n', text)

        return text

    def annotate(self, text):
        """
        Adds title and paragraph tags to a string of marked up text

        :type text: str
        :rtype: str
        """
        # Brute force regex to find title-looking things
        text = re.sub('(?:^|\n)(?:((?:\S+ ){1,3}\S+\. ) *\n? *)?((Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sept|Oct|Nov|Dec)(?:\.?|[a-z]+) +(\d+)(?:st|nd|rd|th)?\.?(?: +(\d{4}))?\.?.*)\n', self.format_title, text)
        # Add closing tags where applicable
        text = re.sub('(?<=.|\n)(?=<div)', '</p></div>', text)

        # Close the final entry and wrap everything in a body tag
        return '<body>{}</p></div></body>'.format(text)

    def format_title(self, matchobj):
        title = (matchobj.group(1) or '') + matchobj.group(2)
        month = Month[matchobj.group(3)].value + 1
        day = matchobj.group(4)
        year = matchobj.group(5)

        if year:
            self.year = year
        month = pad_int(month, 2)
        day = pad_int(day, 2)

        return '<div xml:id="EBA{}{}{}" type="Entry"><p><title>{}</title></p><p>'.format(self.year, month, day, title)

    
def pad_int(x, size):
    number = str(x)
    pad = '0' * (size - len(number))

    return pad + number


main()
